<?xml version="1.0" encoding="UTF-8"?>
<document>
	<title>Iterating memory</title>

	There are 2 ways that you can iterate over memory.

	<section>
		<title>Iterating by size</title>

		This method allows you to iterate over all addresses in memory
		that could be dereferenced to a value of the specified size.

		Before you can start iterating, you will want to specify the
		size of the contents at the addresses. You do that by calling
		<quote>proctal_address_set_size</quote>.

		Here's how you would specify iterating over addresses that
		could hold a value of the size of an int:

		<code type="c">
proctal_address_set_size(proctal, sizeof(int));
		</code>

		Something that you may be aware of is that on x86 ints should
		be at a memory address which is some multiple of 4. Proctal
		also lets you specify alignment restrictions with a call to
		<quote>proctal_address_set_align</quote>.

		This is how you would specify iterating over addresses aligned
		where ints must be:

		<code type="c">
proctal_address_set_align(proctal, alignof(int));
		</code>

		You can also specify at which memory regions the iterator
		should go through. You can set that with a call to
		<quote>proctal_address_set_region</quote>.

		Here's how you would tell Proctal to only iterate over
		addresses in the heap and the stack:

		<code type="c">
proctal_address_set_region(proctal, PROCTAL_REGION_HEAP | PROCTAL_REGION_STACK);
		</code>

		The following macros are defined to identify regions:

		<list>
			<item>PROCTAL_REGION_STACK</item>
			<item>PROCTAL_REGION_HEAP</item>
			<item>PROCTAL_REGION_PROGRAM_CODE</item>
		</list>

		You can also specify whether you want to iterate over readable,
		writable or executable memory addresses. For that you can call
		<quote>proctal_address_set_read</quote>,
		<quote>proctal_address_set_write</quote> and
		<quote>proctal_address_set_execute</quote>, respectively.

		Here's how you would only iterate over readable addresses:

		<code type="c">
proctal_address_set_execute(proctal, 0);
proctal_address_set_write(proctal, 0);
proctal_address_set_read(proctal, 1);
		</code>

		Those are all the options. To begin iterating you must call
		<quote>proctal_address_new</quote>.

		<code type="c">
proctal_address_new(proctal);
		</code>

		And now each call to <quote>proctal_address</quote> will return
		you the current address and move on to the next one.

		<code type="c">
void *address;
while (proctal_address(proctal, &amp;address)) {}
		</code>

		As you can see, <quote>proctal_address</quote> expects you to
		pass the address of a place to store the address. The return
		value is used to indicate success or failure.

		When the return value is 1, it means that the function has
		provided you with an address. When it returns 0 it can mean two
		things. Either the function has iterated over all addresses or
		it has hit an error.

		To find out whether the return value 0 indicates an error, you
		must call <quote>proctal_error</quote>. So this is going to be
		a common idiom:

		<code type="c">
void *address;
while (proctal_address(proctal, &amp;address)) {
	// Use address.
}

// Check if the loop finished because of an error.
if (proctal_error(proctal) {
	// Error handling.
}
		</code>

		When you're done using the iterator, you don't have to do
		anything else. If you'd want to start iterating again with the
		same restrictions, you can just call
		<quote>proctal_address_new</quote>.

		This method is the simplest and easiest to use but comes at a
		performance penalty. It can get really slow to iterate over
		gigabytes of data. The next method works on a lower level with
		fewer function calls that is much faster but not as easy to
		use.
	</section>

	<section>
		<title>Iterating by region</title>

		This method iterates over regions of memory. Programs have
		their memory organized by regions. You may have regions for
		program code, heap, libraries, stack and so on.

		Before you start iterating you can specify what type of regions
		are iterated over by calling
		<quote>proctal_region_set_mask</quote>.

		Here's how you tell Proctal to iterate over heap memory regions:

		<code type="c">
proctal_region_set_mask(proctal, PROCTAL_REGION_HEAP);
		</code>

		You can also specify whether you want to iterate over readable,
		writable or executable memory addresses. For that you can call
		<quote>proctal_region_set_read</quote>,
		<quote>proctal_region_set_write</quote> and
		<quote>proctal_region_set_execute</quote>, respectively.

		Here's how you would only iterate over readable addresses:

		<code type="c">
proctal_region_set_execute(proctal, 0);
proctal_region_set_write(proctal, 0);
proctal_region_set_read(proctal, 1);
		</code>

		Those are all the options. To begin iterating you must call
		<quote>proctal_region_new</quote>.

		<code type="c">
proctal_region_new(proctal);
		</code>

		And now each call to proctal_region will return you the
		starting and ending address of the current region and move on
		to the next one.

		<code type="c">
void *start;
void *end;
while (proctal_region(proctal, &amp;start, &amp;end)) {}
		</code>

		As you can see, <quote>proctal_regions</quote> expects you to
		pass the addresses of places to store the start and end
		addresses. The return value is used to indicate success or
		failure.

		When the return value is 1, it means that the function has
		provided you with addresses. When it returns 0 it can mean two
		things. Either the function has iterated over all regions it
		has hit an error.

		To find out whether the return value 0 indicates an error, you
		must call <quote>proctal_error</quote>. So this is going to be
		a common idiom:

		<code type="c">
void *start;
void *end;
while (proctal_region(proctal, &amp;start, &amp;end)) {
	// Use address.
}

// Check if the loop finished because of an error.
if (proctal_error(proctal) {
	// Error handling.
}
		</code>

		When you're done using the iterator, you don't have to do
		anything else. If you'd want to start iterating again with the
		same restrictions, you can just call
		<quote>proctal_region_new</quote>.
	</section>
</document>
